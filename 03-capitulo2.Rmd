---
output:
  pdf_document: default
  html_document: default
---

```{r message=FALSE, warning=FALSE, include=FALSE}
source("depencias.R")
```

# Distribuciones de frecuencia

```{r}
library("summarytools")

tabla_frec <- function(datos, digits = 2, name = "") {
  tbl <- table(datos)
  mrgns <- round(addmargins(tbl), digits)
  names(mrgns) <- sub("Sum", "Total", names(mrgns))
  props <- round(addmargins(prop.table(tbl)), digits)
  names(props) <- sub("Sum", "Total", names(props))
  res <- data.frame(names(mrgns), c(mrgns), c(props))
  res <- unname(res)
  colnames(res) <- c(name, "f", "f'")
  res
}
```

Una vez identificadas las variables y reconocido su nivel de medición, es necesario darle a la matriz de datos un formato que permita hacer lecturas de los resultados, ya que es imposible observar una tabla que tenga gran cantidad de filas (casos) y muchas columnas (variables).
El siguiente fragmento de matriz de datos:

```{r}
eph.3.18 <- read.csv("bases/archivostxt/usu_individual_T318.txt", sep = ";")
eph.3.18$CH06[eph.3.18$CH06 == -1] <- 0
head(eph.3.18[, -c(1, 4:8, 10, 15:177)])
```

Muestra las primeras variables y primeros casos correspondiente a la aplicación del cuestionario individual de la Encuesta Permanente de Hogares[^cuesteph],  del tercer trimestre de 2018, que tiene `r length(eph.3.18$CH04)` casos. Las variables están codificadas, tanto en su nombre como en sus categorías. Por ejemplo, CH04 es sexo y sus categorías son 1 = varones, 2 = mujeres, CH06 es la edad y los números representan años cumplidos, etc. Esas codificaciones están en el documento *Diseño de Registro de la Base Usuario de la EPH*.[^disenoreg]

Cada columna de la matriz de datos contiene los valores que se han observado en cada uno de los individuos (filas); si se observa verticalmente, cada columna es una secuencia de números; un vector. Para el caso de CH04 (sexo), los primeros 25 valores de esta columna son:

```{r echo=FALSE}
head(eph.3.18$CH04, n = 25)
```

Así presentada, la secuencia se llama serie simple y solo puede analizarse cuando son muy pocos casos, sería imposible en este ejemplo, con `r length(eph.3.18$CH04)` filas.

El más elemental de los resúmenes consiste en contar, para una variable determinada, cuantas apariciones tiene cada categoría. En la columna encabezada CH04 (sexo) pueden contarse cuántos unos (1s) y cuántos doses (2s) hay en total.

## Tablas de distribución de frecuencia

Las tablas resumen los recuentos, en este ejemplo:

```{r}
aux_table <- addmargins(table(eph.3.18$CH04))
names(aux_table) <- sub("Sum", "Total", names(aux_table))
kableExtra::kable_styling(
  knitr::kable(aux_table,
    format = "pandoc", booktabs = TRUE, align = "cc",
    escape = FALSE,
    caption = "Distribución por sexos."
  ),
  latex_options = "striped", full_width = FALSE
)
```

Cuando se rotulan la variable y sus categorías:

```{r}
eph.3.18$sexo <- as.factor(eph.3.18$CH04)
levels(eph.3.18$sexo) <- c("varones", "mujeres")
aux_table <- addmargins(table(eph.3.18$sexo))
names(aux_table) <- sub("Sum", "Total", names(aux_table))
kableExtra::kable_styling(
  knitr::kable(aux_table,
    format = "pandoc", booktabs = TRUE, align = "lc",
    escape = FALSE, col.names = c("sexo", "casos"),
    caption = "Distribución por sexos (categorías rotuladas)."
  ),
  latex_options = "striped", full_width = FALSE
)
```

A la cantidad de casos, que proviene del recuento del número de unos y doses en la columna de sexo, se llama **frecuencia absoluta simple** y se la indica como f. La tabla resulta entonces:

```{r}
kableExtra::kable_styling(
  knitr::kable(aux_table,
    format = "pandoc", booktabs = TRUE, align = "lc",
    escape = FALSE, col.names = c("sexo", "f"),
    caption = "Distribución por sexos: frecuencia absoluta."
  ),
  latex_options = "striped", full_width = FALSE
)
```

El total de `r length(eph.3.18$sexo)` casos resulta de la suma de todas las frecuencias absolutas simples, de manera breve, esto se indica así:   $$\sum_{i=1}^{k}f_i =n$$

Que se lee "La sumatoria de las frecuencias (f) desde 1 hasta k es igual al total de observaciones (n)".
En esa expresión:

- $\sum$ es el símbolo de suma o sumatoria e indica la realización de esa operación (sumar).

- Las $f_i$ son las frecuencias absolutas simples. El subíndice i va cambiando entre categorías.

- La expresión $i=1$ señala desde qué valor de i se inicia la suma, así como k señala la última categoría a sumar. En el ejemplo de las tablas, el valor de $k$ es 2 (solo hay dos categorías), por lo que solo hay dos frecuencias a sumar: $f_1$ y $f_2$, correspondientes a las cantidades de varones y de mujeres.

- $n$ es el total de casos (observaciones).

Lo mismo puede indicarse como:

$$f_1 + f_2 + ⋯ + f_k = n$$

Que, en el caso de la tabla anterior resulta simplemente: 

$$f_1 + f_2 = 27219 + 29660 = 56879$$

||
|:--:|
| La **frecuencia absoluta simple** de cada valor de la variable es el número de casos que asumen ese valor. Se indica $f$. |

Si se quisieran comparar estas frecuencias con las de otra matriz de datos que tuviera un número total de casos diferente de `r length(eph.3.18$sexo)`, sería inadecuado usar los valores absolutos aquí presentados. Por ejemplo, la comparación de la distribución por sexos entre las personas que trabajan en el sector estatal y en el sector privado.

```{r}
estatal <- subset(eph.3.18, eph.3.18$PP04A == 1)
por_sexos_estatal <- addmargins(table(estatal$CH04))
names(por_sexos_estatal) <- sub("Sum", "Total", names(por_sexos_estatal))
kableExtra::kable_styling(
  knitr::kable(por_sexos_estatal,
    format = "pandoc", booktabs = TRUE, align = "cc",
    escape = FALSE, col.names = c("sexo (sector estatal)", "f"),
    caption = "Distribución por sexos según sector de trabajo."
  ),
  latex_options = "striped", full_width = FALSE
)


privado <- subset(eph.3.18, eph.3.18$PP04A == 2)
por_sexos_privado <- addmargins(table(privado$CH04))
names(por_sexos_privado) <- sub("Sum", "Total", names(por_sexos_privado))
kableExtra::kable_styling(
  knitr::kable(por_sexos_privado,
    format = "pandoc", booktabs = TRUE, align = "cc",
    escape = FALSE, col.names = c("sexo (sector privado)", "f")
  ),
  latex_options = "striped", full_width = FALSE
)
```

No es clara la comparación entre el número de mujeres en los dos sectores, porque la cantidad total de casos es muy diferente, por eso es necesario comparar el peso relativo de las mujeres respecto del total, y no su número absoluto, se trata de su contribución al total de casos.

Para calcularlo se divide el número de mujeres en el total general. En el ejemplo, para el sector estatal es `r round(por_sexos_estatal[2] / por_sexos_estatal[3], 3)` que es el `r round(por_sexos_estatal[2] / por_sexos_estatal[3] * 100, 1)`% de los casos. Es decir que las mujeres constituyen una proporción de `r round(por_sexos_estatal[2] / por_sexos_estatal[3], 3)` o bien que representan el `r round(por_sexos_estatal[2] / por_sexos_estatal[3] * 100, 1)`% del total. Mientras que en la segunda tabla, la proporción de mujeres es `r  round(por_sexos_privado[2] / por_sexos_privado[3], 3)` que es el `r round(por_sexos_privado[2] / por_sexos_privado[3] * 100, 1)`% de los casos.

Estas proporciones se denominan **frecuencias relativas simples**, se simbolizan como $f'$ (efe prima), y se calculan dividiendo la frecuencia absoluta por el total. Ahora puede completarse la tabla anterior agregando otra columna.

```{r}
privp <- round(addmargins(prop.table(table(privado$CH04))), 2)
names(privp) <- sub("Sum", "Total", names(privp))
aux_table <- cbind(names(privp), por_sexos_privado, privp)
rownames(aux_table) <- NULL
kableExtra::kable_styling(
  knitr::kable(aux_table,
    format = "pandoc", booktabs = TRUE, align = "ccc",
    escape = FALSE,
    col.names = c("sexo (sector privado)", "f", "f'"),
    caption = "Distribución por sexos sector privado: frecuencias relativas."
  ),
  latex_options = "striped", full_width = FALSE
)
```

El valor 1 que resulta de sumar las dos frecuencias relativas corresponde al 100% de los casos, es decir a las `r nrow(privado)` observaciones. Usando la misma simbología que antes: $$\sum_{i=1}^{k} f'_i =1$$

Que afirma que la suma de las frecuencias relativas simples ($f’$) es igual a uno.
La salida para la variable ESTADO tiene la siguiente forma:

```{r}
aux_table <- addmargins(prop.table(table(eph.3.18$ESTADO)))
names(aux_table) <- sub("Sum", "Total", names(aux_table))
kableExtra::kable_styling(
  knitr::kable(aux_table,
    format = "pandoc", booktabs = TRUE, align = "cc",
    escape = FALSE, digits = c(0, 2),
    col.names = c("ESTADO", "f'"),
    caption = "Condición laboral."
  ),
  latex_options = "striped", full_width = FALSE
)
```

Cuando se codifica, viendo las categorías en el documento *Diseño de registro...*, queda:

```{r}
eph.3.18$ESTADO <- as.factor((eph.3.18$ESTADO))
levels(eph.3.18$ESTADO) <- c("entrevista no realizada", "ocupade", "desocupade", "inactive", "menor de 10 años")
aux_table <- addmargins(prop.table(table(eph.3.18$ESTADO)))
names(aux_table) <- sub("Sum", "Total", names(aux_table))
kableExtra::kable_styling(
  knitr::kable(aux_table,
    format = "pandoc", booktabs = TRUE, align = "lc",
    escape = FALSE, digits = c(0, 2),
    col.names = c("ESTADO", "f'"),
    caption = "Condición laboral (categorías rotuladas)."
  ),
  latex_options = "striped", full_width = FALSE
)
```

Al construir estas tablas de distribución de frecuencias se renuncia a una parte de la información que estaba en la matriz de datos. En ella se podía seguir por la fila a cada persona que respondió al  cuestionario y describirla en cada uno de sus aspectos relevados (variables). Por el contrario, la tabla de distribución de frecuencias de sexo solo dice que hay `r sum(eph.3.18$sexo == "varones")` varones y `r sum(eph.3.18$sexo == "mujeres")` mujeres o, en la tabla de ESTADO, que hay `r sum(eph.3.18$ESTADO == "ocupade")` que están trabajando, `r sum(eph.3.18$ESTADO == "desocupade")` que no trabajan y buscan trabajo, etc., pero no se informa quiénes son. Esta pérdida de información es parte inevitable del proceso en el que se resumen datos, cuanto más sintética sea la presentación, tanta más información habremos perdido. Esto puede visualizarse como el proceso en el que se "toma distancia" de los datos originales: cada vez se tiene una mejor visión de conjunto, pero al mismo tiempo se pierden detalles.

||
|:--:|
| La **frecuencia relativa simple** de cada valor de la variable es la proporción de casos que asumen ese valor. Se indica $f'$. |

Los dos ejemplos mostrados hasta aquí corresponden a variables medidas a nivel nominal, por lo que los números no son más que códigos, no representan orden ni puede considerarse la distancia entre ellos. ¿Qué cambia con un nivel de medición más elevado? Con el mismo principio usado para las variables nominales, la forma de la tabla de distribución de frecuencia para la edad (CH06) de estudiantes de una carrera universitaria sería:

```{r}
edad <- subset(
  eph.3.18, eph.3.18$NIVEL_ED == 5 &
    eph.3.18$CH10 == 1 &
    eph.3.18$CH06 < 55
)$CH06
aux_table <- tabla_frec(edad, digits = 2, "edad")
kableExtra::kable_styling(
  knitr::kable(aux_table,
    format = "pandoc", booktabs = TRUE, align = "ccc",
    escape = FALSE, row.names = FALSE,
    caption = "Distribución por edades."
  ),
  latex_options = "striped", full_width = FALSE
)
```

Sobre esta tabla se pueden calcular otras frecuencias, que respondan a preguntas como ¿cuántas personas de menos de 20 años fueron encuestadas? Para saber eso, hay que contar cuántos casos hay con edades menores a 20: con 17, 18 o 19 años hay `r sum(edad < 20)` casos, que provienen de sumar las frecuencias de esas categorías (`r sum(edad == 17)`+`r sum(edad == 18)`+`r sum(edad == 19)`). 
Así, además de indicar cuántos casos (o qué porcentaje de ellos) tiene determinados valores de la variable, resulta de interés mostrar cuántos (y también qué porcentaje) tienen valores iguales o menores a uno determinado. Esto va a ser indicado por las **frecuencias acumuladas**, que responden a la pregunta por la cantidad de casos que hay por debajo de una categoría de la variable. Pero esto solo está permitido con variables medidas a escala ordinal o superior, porque con variables nominales no se pueden hacer juicios de orden, como decir que una categoría es mayor o menor que otra. El cálculo de las frecuencias acumuladas consiste en contar las frecuencias de la categoría que interesa y sumarla a las frecuencias de las categorías anteriores a ella. Estas frecuencias acumuladas se vuelven relativas al dividirlas por el total de casos y dan lugar a las **frecuencias relativas acumuladas**. En el ejemplo de la distribución de las edades de estudiantes resulta:

```{r echo=FALSE}
edad_frec <- tabla_frec(edad, digits = 3, "edad")
edad_frec[, "F"] <- cumsum(edad_frec[, "f"])
edad_frec[, "F'"] <- cumsum(edad_frec[, "f'"])
edad_frec[nrow(edad_frec), c("F", "F'")] <- ""
edad_frec[nrow(edad_frec) - 1, "F'"] <- 1
kableExtra::kable_styling(
  knitr::kable(edad_frec,
    format = "pandoc", booktabs = TRUE, align = "ccccc",
    escape = FALSE, row.names = FALSE,
    caption = "Distribución por edades: frecuencias acumuladas."
  ),
  latex_options = "striped", full_width = FALSE
)
```

Se agregaron dos columnas más, las frecuencias acumuladas absolutas (F) y relativas (F'). Las primeras se obtuvieron sumando a la frecuencia absoluta de cada categoría, las frecuencias absolutas de las categorías anteriores a ella. Así, la primera categoría tiene frecuencia acumulada igual a la absoluta simple, porque no hay ningún caso por debajo de 17 años; la segunda es `r edad_frec[2, "F"]`, que proviene de contar los `r edad_frec[2, "f"]` de la segunda categoría y sumarle los `r edad_frec[1, "f"]` de la anterior y del mismo modo se construyen las siguientes. La última categoría tiene por frecuencia absoluta acumulada al total de casos (en el ejemplo `r edad_frec[nrow(edad_frec)-1, "F"]`), porque el conjunto completo (los `r edad_frec[nrow(edad_frec)-1, "F"]`) está en esa categoría o por debajo de ella, es decir, nadie tiene más de `r edad_frec[nrow(edad_frec)-1, "edad"]`. La lectura que hacemos de estas frecuencias es que, por ejemplo, "hay `r sum(edad <= 20)` estudiantes que tienen 20 años o menos."

||
|:--:|
| La **frecuencia absoluta acumulada** de cada valor de la variable es la cantidad de casos que asumen ese valor y todos los valores menores a él. Se indica $F$. |

La última columna de la tabla es la transformación en relativas de las frecuencias absolutas acumuladas y se logra con el mismo procedimiento que se usó para las relativas simples; el de dividir por el total de casos. Se denominan frecuencias acumuladas relativas. La lectura de una de estas frecuencias es, por ejemplo, que el $46\%$ de las personas que respondieron tiene $22$ años *o menos*. Notemos la diferencia con la frecuencia relativa simple: el $9.7\%$ del total tiene *exactamente* $22$ años. La frecuencia relativa simple es la fracción de casos que tienen una determinada categoría (o valor) de la variable, la frecuencia relativa acumulada es la fracción de casos que tiene un valor de la variable o cualquiera de los anteriores a ese valor. Por eso la lectura del ejemplo es "22 años" en la simple y "22 años o menos" en la acumulada.

||
|:--:|
| La **frecuencia relativa acumulada** de cada valor de la variable es la proporción de casos que asumen ese valor y todos los valores menores a él. Se indica $F'$. |

## Recategorización

Como se señaló antes, hay dos situaciones en que se apela a la presentación de los valores de la variable en forma agrupada, es decir que se recategoriza la variable en intervalos: si se trata de una variable discreta con muchas categorías (como la edad) o si es una variable continua.

### Variable discreta con muchas categorías

La construcción de intervalos es una elección; podríamos optar por mostrar todas las categorías, con lo que quedaría una tabla grande, pero muy detallada; o bien agrupar para ganar en sencillez de presentación. Es muy común optar por la construcción de intervalos, de manera de mantener la cantidad de categorías entre cinco y diez. En tablas en que se precisa mostrar mucho detalle, se opta por la enumeración de todas las categorías.

### Variable continua

Si la variable es continua la recategorización es necesaria, porque no es posible mostrar "todas las categorías" de una variable continua, ya que éstas son, en teoría, infinitas[^categ_inf]. Para resolver el problema de la exclusión mutua no es posible pasar de un valor al siguiente, por lo que se utiliza un criterio de intervalos abiertos o cerrados. Esto quiere decir que si una categoría es 1.75 - 1.85, se entiende que entran en el intervalo quienes tengan estatura superior a 1.75 (excluido este valor) hasta 1.85 (incluido). Se dice que este intervalo es abierto a la izquierda (excluye al valor inicial) y cerrado a la derecha (incluye al valor final). Una persona de 1.75 se contará en el intervalo anterior: 1.65 - 1.75, que sí incluye al 1.75 y excluye al 1.65. A continuación se usará la convención de intervalos abiertos a la izquierda y cerrados a la derecha, eso se indica $(L_i; L_s]$.

### Formas de recategorizar  
Se utilizan tres criterios para definir la amplitud de los intervalos: de amplitud igual, proporcional y teórica.


#### Intervalos de amplitud igual

Se organizan los valores de la variable para lograr que el campo de variación quede dividido en tantos intervalos como se desee siendo ellos de igual amplitud. Si es una variable discreta y la cantidad de categorías originales no es múltiplo de número de intervalos que se desean, la cantidad de valores en cada uno no será idéntica, sino aproximadamente igual. La variable edad, con cuatro categorías queda, según este criterio, así: 

```{r}
edad4 <- factor(cut(subset(
  eph.3.18, eph.3.18$NIVEL_ED == 5 &
    eph.3.18$CH10 == 1 &
    eph.3.18$CH06 < 55
)$CH06, breaks = 4))
tabla2 <- table(edad4)
kableExtra::kable_styling(
  knitr::kable(tabla2,
    format = "pandoc", booktabs = TRUE, align = "lc",
    escape = FALSE, row.names = FALSE,
    col.names = c("EdadCat", "f"),
    caption = "Categorización de la edad en intervalos de igual amplitud."
  ),
  latex_options = "striped", full_width = FALSE
)
```

Los intervalos son de la misma amplitud, 9.2 años, que es la distancia que hay entre los límites de cada uno de ellos. El inconveniente es que el primero de los intervalos tiene más del 70% de las observaciones, con lo que se pierde detalle de la distribuciión.

#### Intervalos de amplitud proporcional

Este criterio busca que los intervalos incluyan aproximadamente a la misma cantidad de casos, por lo que su amplitud puede ser diferente. En el capítulo siguiente se verá que los puntos para establecer los cortes de intervalos, se llaman cuantiles. Por ahora interesa que con este criterio se logran grupos homogéneos en términos de cantidad de observaciones. La edad de estudiantes de una carrera universitaria, con cuatro intervalos resulta así categorizada:

```{r}
universitarios <- subset(
  eph.3.18, eph.3.18$NIVEL_ED == 5 &
    eph.3.18$CH10 == 1 &
    eph.3.18$CH06 < 55
)

universitarios$edad4.p <- factor(cut(
  universitarios$CH06,
  breaks = c(
    min(universitarios$CH06),
    quantile(universitarios$CH06, .25),
    quantile(universitarios$CH06, .5),
    quantile(universitarios$CH06, .75),
    max(universitarios$CH06)
  )
))

tabla3 <- table(universitarios$edad4.p)

kableExtra::kable_styling(
  knitr::kable(tabla3,
    format = "pandoc", booktabs = TRUE, align = "lc",
    escape = FALSE, row.names = FALSE,
    col.names = c("EdadCat", "f"),
    caption = "Categorización de la edad en intervalos proporcionales."
  ),
  latex_options = "striped", full_width = FALSE
)
```

Ahora la distribución está más equilibrada (hay alrededor de 1000 casos en cada una), y los intervalos tienen amplitud diferente. El último intervalo, de 26 años de  amplitud, tiene casi la misma cantidad de casos que el primero, que cubre tres años.

#### Intervalos de amplitud teórica

Aquí la decisión por el lugar donde establecer los puntos de corte para definir los intervalos es del investigador y debe estar fundamentada. Si se considera que, según el año  en que ingresaron a la carrera, la edad esperada de las personas observadas es entre 19 y 20 años, se pueden hacer cuatro intervalos con quienes tienen menos de esa edad, quienes tienen la edad esperada, quienes tienen más de esa edad y el grupo "más mayor" (superan los 40 años). Los intervalos resultan así:

```{r}
universitarios$edad4.t <- factor(cut(
  universitarios$CH06,
  breaks = c(
    min(universitarios$CH06),
    18,
    20,
    40,
    max(universitarios$CH06)
  )
))

tabla4 <- table(universitarios$edad4.t)

kableExtra::kable_styling(
  knitr::kable(tabla4,
    format = "pandoc", booktabs = TRUE, align = "lc",
    escape = FALSE, row.names = FALSE,
    col.names = c("EdadCat", "f"),
    caption = "Categorización de la edad con un criterio teórico."
  ),
  latex_options = "striped", full_width = FALSE
)
```

El intervalo (18,20] incluye las edades de 19 y 20 años, porque es abierto a la izquierda.

## La presentación gráfica de los resultados

En la misma dirección de ofrecer una presentación de los datos recogidos que sea accesible para la interpretación, se muestran a continuación las representaciones gráficas que más se usan para describir información cuantitativa. Nuevamente aquí se debe aceptar la pérdida de parte de la información que se muestra, en aras del impacto visual y facilidad de lectura que proveen los gráficos.
Cuando se trata de variables nominales, normalmente con pocas categorías, son adecuados los **gráficos de barras**. En el gráfico \@ref(fig:estadobarras) se muestra un ejemplo para la tabla de la variable "ESTADO".


```{r estadobarras, echo=FALSE, message=FALSE, warning=FALSE, fig.cap="Condición laboral: frecuencias absolutas (barras adyacentes).", fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
eph.3.18$ESTADO <- as.factor(eph.3.18$ESTADO)
levels(eph.3.18$ESTADO) <- c(NA, "ocupade", "desocupade", "inactive", NA)
ggplot(eph.3.18) +
  geom_bar(aes(ESTADO), fill = "green") +
  xlab("actividad") +
  ylab("casos") +
  theme_tufte(base_size = 9)
```

La categoría NA (not available) reúne a quienes no respondieron al cuestionario y a los menores de 10 años, que no se les hace la pregunta. En el gráfico \@ref(fig:apiladasabs), se representa la misma información en barras apiladas.

```{r apiladasabs, fig.cap="Condición laboral: frecuencias absolutas (barras apiladas).", fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
estado.tabla <- as.data.frame(table(eph.3.18$ESTADO))
names(estado.tabla) <- c("estado", "f")
ggplot(estado.tabla) +
  geom_bar(aes(x = "", y = f, fill = estado), width = 1, stat = "identity") +
  theme_tufte(base_size = 9) +
  ylab("Frecuencia absoluta") +
  xlab("estado")
```

En \@ref(fig:apiladasrel), se muestran, con el mismo tipo de representación, las frecuencias relativas.

```{r apiladasrel, fig.cap="Condición laboral: frecuencias relativas (barras apiladas).", fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
estado.tabla.p <- as.data.frame(prop.table(table(eph.3.18$ESTADO)))
names(estado.tabla.p) <- c("estado", "fr")
ggplot(estado.tabla.p) +
  geom_bar(aes(x = "", y = fr, fill = estado), width = 1, stat = "identity") +
  theme_tufte(base_size = 9) +
  ylab("Frecuencia relativa") +
  xlab("estado")
```

Para variables categóricas también se usa el **gráfico de sectores**, que se ilustra en \@ref(fig:estadosectores)

```{r estadosectores, fig.cap="Condición laboral: frecuencias relativas (gráfico de sectores).", fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(estado.tabla.p) +
  geom_bar(aes(x = "", y = fr, fill = estado), width = 1, stat = "identity") +
  theme_tufte(base_size = 9) +
  ylab("Frecuencia relativa") +
  xlab("estado") +
  coord_polar("y") +
  scale_fill_brewer(palette = "Dark2") +
  theme(axis.text.x = element_blank())
```


Este gráfico solo es adecuado cuando la variable tiene pocas categorías (no más de cuatro) y además cuando las frecuencias difieren sustancialmente. De lo contrario, resulta muy difícil apreciar diferencias entre ángulos, éstas son mucho más claras entre alturas de barras. La opción de agregar una leyenda con los porcentajes resuelve este problema, pero hace perder parte de la claridad visual del gráfico.  

La representación gráfica de la tabla de frecuencias de variables cuantitativas (categorizadas), se llama **histograma**, se observa en \@ref(fig:histedades):

```{r histedades, fig.cap="Histograma de edades.", fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(eph.3.18) +
  geom_histogram(aes(CH06), fill = "green", binwidth = 1) + xlab("edad") +
  ylab("f") +
  theme_tufte(base_size = 9)
```

El ancho de los rectángulos es la amplitud de las categorías que resultan de la categorización. Esta siempre se realiza con el criterio de intervalos iguales, que puede regularse, por ejemplo, si se toman intervalos de 5 años, el histograma queda como en el gráfico \@ref(fig:histedadcinco).

```{r histedadcinco, fig.cap="Histograma de edades: categorías de 5 años.", fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(eph.3.18) +
  geom_histogram(aes(CH06), fill = "green", binwidth = 5) +
  xlab("edad") +
  ylab("f") +
  theme_tufte(base_size = 9)
```

Cuando estos rectángulos se unen en sus puntos medios por una poligonal, resulta el **polígono de frecuencias** del gráfico \@ref(fig:poligon):

```{r poligon, fig.cap="Polígono de frecuencias de las edades sobre el histograma.", fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(eph.3.18) +
  geom_histogram(aes(CH06), fill = "green", binwidth = 5) +
  xlab("edad") +
  ylab("f") +
  theme_tufte(base_size = 9) +
  geom_freqpoly(aes(CH06), binwidth = 5)
```

Al polígono le fueron agregados agregaron dos intervalos, uno anterior al primero y uno posterior al último, cuyas frecuencias son cero, con el objetivo de "cerrar" el polígono sobre el eje horizontal.
El área que queda bajo este polígono es igual a la que encierran los rectángulos del histograma, y valdrá $n$ si se grafican frecuencias absolutas ó $1$ si son las relativas.  
Cuando se muestra solo el polígono (gráfico \@ref(fig:solopoli)), se tiene una representacón simplificada de la distribución, que sirve para apreciar aspectos que se verán más adelante: forma, dispersión, simetría, etc. Además es preferible presentar en el eje vertical, frecuencias relativas antes que absolutas, para facilitar las comparaciones.

```{r solopoli, fig.cap="Polígono de frecuencias de las edades.", fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(eph.3.18) +
  geom_freqpoly(aes(CH06, y = (..count..) / sum(..count..)), binwidth = 5) +
  xlab("edad") +
  ylab("f'") +
  theme_tufte(base_size = 9)
```

En variables cuantitativas es posible calcular frecuencias acumuladas, por lo que también ellas pueden representarse gráficamente. Si la variable es discreta, el gráfico se llama **gráfico de escalones**, cada valor aporta su frecuencia, que "salta" en el valor siguiente, por eso el gráfico tiene forma escalonada. Con la variable edad (CH06) de la EPH el gráfico de escalones es el de \@ref(fig:escalones).

```{r escalones, fig.cap="Ojiva de las edades.", fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(eph.3.18) +
  stat_ecdf(geom = "step", aes(CH06)) +
  xlab("edad") +
  ylab("F'") +
  theme_tufte(base_size = 9)
```

En el que el eje horizontal se indican los valores de la variable discreta edad y en el vertical las frecuencias acumuladas de cada categoría (de cada valor discreto).  
Si la variable es continua, se trata de la **ojiva de Galton**, las frecuencias se van acumulando gradualmente a medida que aumenta el valor de la variable. El gráfico \@ref(fig:ojivabayley) muestra las frecuencias acumuladas de los pesos al nacer de un conjunto grande de niños y niñas que fueron evaluados con la prueba de Bayley:

```{r ojivabayley, fig.cap="Ojiva de los pesos al nacer.", fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
bayley <- read.csv("bases/archivostxt/bayley.txt", sep = ";", dec = ",")
set.seed(8818) # semilla para los random numbers
bayley$peso.nac <- rnorm(454, 3000, 500) # hubo que inventarlo, porque no estaba

ggplot(bayley) +
  stat_ecdf(aes(peso.nac)) +
  xlab("peso al nacer (en gramos)") +
  ylab("F'") +
  theme_tufte(base_size = 9)
```

Debido a que en la práctica las variables nunca son continuas, siempre habra "escalones" cuyo tamaño es el de la mínima medición posible de la variable (la apreciación del instrumento con que se mide).  
La ojiva de Galton tiene otra virtud además de la claridad visual, ya que permite interpolar valores no observados, o que no aparecen en la tabla. Así, con el gráfico podemos responder a la pregunta ¿Qué proporción nación con `r round(quantile(bayley$peso.nac, .17), 0)` g o menos? La respuesta consiste en buscar el valor `r round(quantile(bayley$peso.nac, .17), 0)` gramos en el eje x, e identificar la frecuencia acumulada que le corresponde, como se muestra en \@ref(fig:estimaacumulada). 

```{r estimaacumulada, fig.cap="Estimación de la frecuencia acumulada para un valor del peso al nacer.", fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(bayley) +
  stat_ecdf(aes(peso.nac)) +
  geom_segment(aes(
    x = quantile(bayley$peso.nac, .17),
    y = 0,
    yend = .17,
    xend = quantile(bayley$peso.nac, .17)
  )) +
  geom_segment(aes(
    xend = 0,
    yend = .17,
    x = quantile(bayley$peso.nac, .17),
    y = .17
  ),
  arrow = arrow(length = unit(0.1, "inches"))
  ) +
  xlab("peso al nacer (en gramos)") +
  ylab("F'") +
  theme_tufte(base_size = 9)
```

En este ejemplo, la ordenada (valor en el eje vertical) correspondiente a los `r round(quantile(bayley$peso.nac, .17), 0)` gramos es aproximadamente $0.17$, este resultado se lee diciendo que, de esta muestra, el $17\%$ de quienes se sometieron a la evaluación nació con `r round(quantile(bayley$peso.nac, .17), 0)` gramos o menos. En los capítulos siguientes veremos otras aplicaciones útiles de este procedimiento.  
Además, el establecimiento de los límites de los intervalos según el criterio proporcional, puede realizarse en base a este gráfico. Según cuántos intervalos se quiera construir, se ubican los puntos correspondientes a las frecuencias acumuladas en el eje vertical y se buscan los valores de la variable (eje horizontal), que delimitan los intervalos. Por ejemplo, para cuatro intervalos, cada uno debe contener aproximadamente el 25% de los casos, que corresponden a las frecuencias acumuladas de 25, 50 y 75%. En el gráfico \@ref(fig:cortacuatro) se ilustra el procedimiento; partiendo de las frecuencias acumuladas en el eje vertical, que son los valores de ${F}'$ de $0.25$, $0.50$ y $0.75$, se buscan los valores de la variable en el horizontal.

```{r cortacuatro, echo=FALSE, fig.cap="Identificación de los valores de la variable para determinadas frecuencias acumuladas.", fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(bayley) +
  stat_ecdf(aes(peso.nac)) +
  geom_segment(aes(
    x = 0,
    xend = quantile(bayley$peso.nac, .25),
    y = .25,
    yend = .25
  )) +
  geom_segment(aes(
    xend = quantile(bayley$peso.nac, .25),
    yend = 0,
    x = quantile(bayley$peso.nac, .25),
    y = .25
  ),
  arrow = arrow(type = "closed", length = unit(0.1, "inches"))
  ) +
  geom_segment(aes(
    x = 0,
    xend = quantile(bayley$peso.nac, .5),
    y = .5,
    yend = .5
  )) +
  geom_segment(aes(
    xend = quantile(bayley$peso.nac, .5),
    yend = 0,
    x = quantile(bayley$peso.nac, .5),
    y = .5
  ),
  arrow = arrow(type = "closed", length = unit(0.1, "inches"))
  ) +
  geom_segment(aes(
    x = 0,
    xend = quantile(bayley$peso.nac, .75),
    y = .75,
    yend = .75
  )) +
  geom_segment(aes(
    xend = quantile(bayley$peso.nac, .75),
    yend = 0,
    x = quantile(bayley$peso.nac, .75),
    y = .75
  ),
  arrow = arrow(type = "closed", length = unit(0.1, "inches"))
  ) +
  xlab("peso al nacer (en gramos)") +
  ylab("F'") +
  theme_tufte(base_size = 9)
```

Los valores hallados corresponden a `r round(quantile(bayley$peso.nac, .25), 0)`, `r round(quantile(bayley$peso.nac, .5), 0)` y `r round(quantile(bayley$peso.nac, .75), 0)` gramos. Que quiere decir que un cuarto nació con pesos entre el mínimo y `r round(quantile(bayley$peso.nac, .25), 0)`, otro cuarto pesó entre `r round(quantile(bayley$peso.nac, .25), 0)` y `r round(quantile(bayley$peso.nac, .5), 0)` gramos, y así con los demás. La distribución de frecuencias de esta variable así categorizada resulta:

```{r}
peso.nac4 <- factor(cut(
  bayley$peso.nac,
  breaks = c(
    min(bayley$peso.nac),
    quantile(bayley$peso.nac, .25),
    quantile(bayley$peso.nac, .5),
    quantile(bayley$peso.nac, .75),
    max(bayley$peso.nac)
  ),
  dig.lab = 5
))

tabla5 <- round(table(peso.nac4), 0)
kableExtra::kable_styling(
  knitr::kable(tabla5,
    format = "pandoc", booktabs = TRUE, align = "lc",
    escape = FALSE, row.names = FALSE,
    col.names = c("Peso.nacCat", "f"),
    caption = "Distribución de los pesos al nacer categorizados en cuatro intervalos proporcionales."
  ),
  latex_options = "striped", full_width = FALSE
)
```

[^categ_inf]: La cantidad de valores depende de la precisión con que se haga la medición.

\pagebreak  

## Hacerlo en R  
Volvemos  a leer la base que se trabajó en el capítulo anterior:  
```{r echo=TRUE, warning=FALSE}
base.ejemplo <- read.table("bases/archivostxt/base2019.txt",
  header = TRUE, sep = " ", na.strings = "999"
)
```

Y repetimos las operaciones anteriores, de dar nombre a las variables, y de tranformar en factor y etiquetar las variables que corresponda (para esto alcanza con copiar y pegar las instrucciones del capítulo anterior):  
```{r warning=FALSE, echo=TRUE}
# nombres de columnas:
names(base.ejemplo) <- c(
  "caso", "grupo", "n.cuest", "nombre", "sexo", "genero",
  "edad", "acceso.redes", "red.usada", "red.otra",
  "tiempo.red", "con.q.vive", "relacion.otros",
  "q.aporta", "q.aporta.amigos", "edad.partida",
  "razon.partida",
  "razon.partida.otra", "calidad.sueño",
  "preocupacion", "golpeo", "robo", "cuanto.da", "comision"
)

# transformar en factor y etiquetar las nominales:
base.ejemplo$sexo <- as.factor(base.ejemplo$sexo)
levels(base.ejemplo$sexo) <- c("varones", "mujeres")

base.ejemplo$con.q.vive <- as.factor(base.ejemplo$con.q.vive)
levels(base.ejemplo$con.q.vive) <- c(
  "flia.origen", "flia.nueva",
  "hermanes.o.amigues", "solo",
  "con.otres"
)

base.ejemplo$q.aporta <- as.factor(base.ejemplo$q.aporta)
levels(base.ejemplo$q.aporta) <- c(
  "el.mismo", "flia.origen",
  "flia.nueva", "entre.amigos"
)

base.ejemplo$acceso.redes <- as.factor(base.ejemplo$acceso.redes)
levels(base.ejemplo$acceso.redes) <- c("si", "no")

base.ejemplo$red.usada <- as.factor(base.ejemplo$red.usada)
levels(base.ejemplo$red.usada) <- c(
  "Instagram", "Facebook", "Twitter",
  "Linkedin", "Tinder/Grindr/happn",
  "Snapchat", "Ninguna", "Otra"
)

base.ejemplo$razon.partida <- as.factor(
  base.ejemplo$razon.partida
)
levels(base.ejemplo$razon.partida) <- c(
  "estudio", "nueva.flia", "ganas", "otras"
)
```

### Tablas univariadas  

Las tablas de distribución de frecuencias se solicitan con un comando del paquete {base} que se llama `table`, que tiene como argumento la variable cuya tabla se pide. Recordemos que para hacer referencia a una variable, se debe indicar el nombre de la matriz de datos de donde proviene, seguida del signo pesos y luego el nombre de la variable. Así, para la tabla de distribución de frecuencias de la variable sexo:
```{r echo=TRUE}
table(base.ejemplo$sexo)
```

Para "quien aporta":
```{r echo=TRUE}
table(base.ejemplo$q.aporta)
```

Por defecto, este comando descarta los casos perdidos (los NA). Si se los quiere ver,  hay que pedirlo expresamente:

```{r echo=TRUE}
table(base.ejemplo$q.aporta, useNA = "always")
```

Las opciones de `useNA` son "$no$", que es la que se aplica por defecto, "$ifany$" (si hay alguno) y la que hemos usado en este ejemplo, "$always$" (siempre).  

Existe un paquete especializado para descripciones estadísticas, llamado {summarytools} que contiene herramientas que simplifican operaciones y ofrecen una presentación más familiar de las tablas. Primero se lo debe instalar:  

```{r eval=FALSE, message=FALSE, warning=FALSE, echo=TRUE}
install.packages("summarytools")
```

Y cargarlo en la sesión:  
```{r  echo=TRUE, message=FALSE, warning=FALSE}
library("summarytools")
```

En este paquete, el comando para pedir una tabla es `freq`. Para la misma variable anterior:

```{r echo=TRUE}
freq(base.ejemplo$q.aporta)
```

La diferencia entre frecuencias válidas y totales es que las primeras descuentan los casos perdidos (NA). Si bien la tabla tiene ahora mejor aspecto, las columnas 3 y 5 (correspondientes a frecuencias acumuladas), no pueden interpretarse, porque esta variable no admite frecuencias acumuladas, que este comando calcula por defecto. Puede solicitarse expresamente que no lo haga:  
```{r echo=TRUE}
freq(base.ejemplo$q.aporta, cumul = FALSE)
```

Y se obtienen frecuencias absolutas y relativas, estas últimas respecto de los casos válidos y respecto del total de casos.  
Si la variable es ordinal, las frecuencias acumuladas sí admiten interpretación. Para la variable "ocasión en que golpeó a alguien", tenemos:  

```{r echo=TRUE}

freq(base.ejemplo$golpeo)
```

La salida se puede simplificar si no hay interés en un análisis puntual sobre los casos perdidos, eliminando su aparición. En el comando `freq`, el argumento `report.nas=FALSE` establece que se elimine la referencia a los casos perdidos, ya que aun cuando no haya, la tabla los menciona, con frecuencia cero.  
```{r echo=TRUE}
freq(base.ejemplo$golpeo, report.nas = FALSE)
```

Que es la versión más familiar de la tabla. con frecuencias absolutas, relativas simples y acumuladas y ya no hay mención a válidos o totales, porque solo están presentes los válidos.  

### Recategorización  
La construcción de categorías a partir de una variable continua, se realiza con el comando `cut`, cuyo argumento contiene a la variable que se va a recategorizar, y una instrucción `breaks=` que especifica el modo de hacer los cortes, esta instrucción difiere según los tipos de recategorización.  
Para ver los comandos, vamos a generar nuevas variables en la base, que se llaman edad4i, edad4p y edad4t (edad en cuatro categorías, con criterio de amplitud igual, proporcional y teórica), y definimos esas categorías de las tres maneras diferentes que se han visto. Antes de eso vamos a eliminar de la base los casos que no tengan información en la variable edad. El modo de hacerlo es redefinir el data frame base.ejemplo, como un subconjunto de él que solo contenga los casos para los cuales la variable edad no es NA:  
```{r echo=TRUE}
base.ejemplo <- subset(
  base.ejemplo,
  is.na(base.ejemplo$edad) == FALSE
)
```

Ahora la base tiene 4991 observaciones, como se ve en el panel superior derecho.

#### Intervalos de amplitud igual  

Para que los intervalos sean iguales, en el argumento `breaks` solo se indica la cantidad de ellos que se quiere, en este caso, cuatro:  
```{r echo=TRUE}
base.ejemplo$edad4i <- cut(base.ejemplo$edad, breaks = 4)
```

Y pedimos una tabla:  

```{r echo=TRUE}
freq(base.ejemplo$edad4i, report.nas = FALSE)
```
  
Los intervalos se presentan con un paréntesis a la izquierda y un corchete a la derecha, lo que indica que los intervalos son abiertos a la izquierda y cerrados a la derecha, incluyen al límite superior y excluyen al inferior. Por ejemplo las personas con edad 27 años están contadas en el primer intervalo y no en el segundo, aunque el 27 aparezca en ambos.

#### Intervalos de amplitud proporcional

Para lograr que cada intervalo tenga aproximadamente la misma proporción de casos, primero hay que saber cuál es esa proporción. En este ejemplo, son cuatro intervalos, por lo que un cuarto de los casos debe estar en cada uno, es decir el 25%. En el próximo capítulo se definirán medidas resumen que marcan estos puntos de corte, se denominan cuantiles. Para este ejemplo, hay que cortar el campo de variación en los valores de la variable que acumulen 25%, 50% y 75%, de modo que entre cada par de ellos quede 25% de casos. Esos números se llaman cuantiles 0.25, 0.50 y 0.75. En el argumento `breaks` se indican, concatenados, cada uno de los límites de los intervalos desde el mínimo valor de la variable (`min()`), los cuantiles .25, .50 y .75 y finalmente el máximo (`max()`):  
```{r echo=TRUE}
base.ejemplo$edad4p <- cut(base.ejemplo$edad,
  breaks = c(
    min(base.ejemplo$edad), # inicio
    quantile(base.ejemplo$edad, .25), # primer corte: 25% acumulado
    quantile(base.ejemplo$edad, .50), # segundo corte: 50% acumulado
    quantile(base.ejemplo$edad, .75), # tercer corte: 75% acumulado
    max(base.ejemplo$edad) # fin
  )
)
```

La tabla es:  

```{r}
freq(base.ejemplo$edad4p, report.nas = FALSE)
```

Como se trata de una variable discreta, la aproximación del 25% en cada intervalo no es muy cercana. En este ejemplo sucede que la edad 18 años tiene muchos casos, por lo que incluirla en el primer intervalo o en el segundo, cambia mucho la proporción de casos que quedan dentro del intervalo.  

#### Intervalos de amplitud teórica

De mismo modo que antes, se indica al argumento `breaks`, la  concatenación de los puntos de corte, solo que éstos se establecen de antemano, por ejemplo, para hacer grupos 15-18, 19-23, 24-35 y 36 en adelante, pedimos:  

```{r echo=TRUE}
base.ejemplo$edad4t <- cut(base.ejemplo$edad,
  breaks = c(
    min(base.ejemplo$edad), 18,
    23, 35, max(base.ejemplo$edad)
  )
)
```

La tabla resulta:
```{r echo=TRUE}
freq(base.ejemplo$edad4t, report.nas = FALSE)
```

### Representaciones gráficas

El paquete {base} contiene rutinas elementales de graficación, sin embargo, desde aquí vamos a empezar a usar un paquete específico para eso; `ggplot2`, que debe instalarse
```{r echo=TRUE, eval=FALSE}
install.packages("ggplot2")
```

y cargarse en la sesión  
```{r echo=TRUE}
library("ggplot2")
```

La construcción de los gráficos en `ggplot` se hace por medio de capas que se van agregando. Las capas tienen cinco componentes:  

-  Los datos, que es la base de donde provienen la variables que se van a graficar. Si más tarde se grafica lo mismo para otra base, solo se debe cambiar ese origen, lo mismo si la base se modifica.  
-  Un conjunto de mapeos estéticos (`aes`), que describen el modo en que las variables de la base van a ser representadas en las propiedades estéticas de la capa.  -  El `geom`, que describe la figura geométrica que se va a usar para dibujar la capa.  
-  La transformación estadística (`stat`) que opera sobre los datos originales para sintetizarlos de modo que se los pueda representar.  
-  Los  ajustes de posición  

Cada figura geométrica (`geom`) tiene asociada una transformación estadística por defecto, por lo que no es necesario especificarla, salvo que se quiera modificar. Por ejemplo si los datos para un gráfico provienen de una matriz de datos (`data.frame`), la tranformación consiste en contar las ocurrencias de cada valor, ese es el `stat` por defecto. Pero si se quiere graficar desde una tabla de distribución de frecuencias, entonces en lugar de contar las veces que aparece cada categoría, hay que considerar las frecuencias. En este último caso, será necesario especificar una transformación diferente.    

#### Creación de un gráfico  

La primera instrucción para crear un gráfico es `ggplot()`. Esta instrucción va a tener como argumento, la matriz de donde provienen las variables a graficar. Puede incluirse el mapeo estético también, pero en este ejemplo lo vamos a agregar en las capas que indican el tipo de gráfico.  
Si se aplica ese comando a la base.ejemplo:
```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(base.ejemplo) + theme_gray(base_size = 9)
```

El resultado son solo los ejes, no se ha indicado aun qué variables graficar ni qué tipo de gráfico hacer. Eso se especifica en las capas.  
Para hacer un gráfico de barras, luego de indicar sobre qué base se va a trabajar, en el argumento de ggplot, se agrega una capa de barras (`geom_bar`) con la variable que se va a representar (no hace falta indicar de qué matriz de datos proviene, eso ya está en el argumento de `ggplot`):  

```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(base.ejemplo) + geom_bar(aes(red.usada)) + theme_gray(base_size = 9)
```

Y vamos a mejorarlo en su aspecto. Para quitar los NA, tomamos como argumento de ggplot, no la base completa, sino un subconjunto que no tenga NA en esta variable:

```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(subset(base.ejemplo, is.na(base.ejemplo$red.usada) == FALSE)) +
  geom_bar(aes(red.usada)) + theme_gray(base_size = 9)
```

Además de hacer el gráfico (ejecutar el comando) podemos guardarlo como un objeto, lo llamamos p1:
```{r echo=TRUE}
p1 <- ggplot(subset(base.ejemplo, is.na(base.ejemplo$red.usada) == FALSE)) +
  geom_bar(aes(red.usada)) +
  theme_gray(base_size = 9)
```

El objeto (de clase `ggplot`) aparece en el panel superior derecho. A las capas subsiguientes las agregamos sobre p1. Una capa de rótulos y se crea p2:


```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
(p2 <- p1 + xlab("Red más usada") + ylab("cantidad de casos"))
```

El paréntesis que encierra toda la expresión se usa  para que, al mismo tiempo que se defina el objeto p2, se ejecute el comando y se vea el gráfico.
Las etiquetas de los ejes se vuelven más legibles si se giran los ejes:

```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
p2 + coord_flip()
```


Vamos a usar este ejemplo para ilustrar la diferencia entre "fijar" y "mapear" a un atributo estético, que en este caso será el color de relleno de las barras, con el comando `fill` (rellenar). Fijar el color es simplemente establecerlo como preferencia para todas las barras, es un argumento de la capa `geom_bar`:


```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(subset(base.ejemplo, is.na(base.ejemplo$red.usada) == FALSE)) +
  geom_bar(aes(red.usada), fill = "green") + coord_flip()
```

Por el contrario, "mapear" es pedir que el color de relleno cambie en base a las categorías de una variable que se especifica, éste es un argumento de `aes`. Solo para ver los efectos, lo usamos con la misma variable que se representa en el eje:  
```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(subset(base.ejemplo, is.na(base.ejemplo$red.usada) == FALSE)) +
  geom_bar(aes(red.usada, fill = red.usada)) + coord_flip()
```

Y en el gráfico el cambio se ve en que se usó un color para cada categoría de red.usada.  


Dos diferencias importantes en la sintaxis:  
- el comando `fill` va dentro de `aes` cuando se mapea y fuera cuando se fija  
- el color fijo (green en este ejemplo) va entre comillas, el nombre de la variable, no.  


En este ejemplo, el mapeo no aporta ninguna información nueva, ya que el nombre de la red está en el eje. Sin embargo, el mapeo es muy útil para introducir otra variable y ver las diferencias, por ejemplo, para observar la diferencia en la preferencia de redes según sexo. Para hacerlo, se recorta la matriz de datos y se retienen solo los casos que no sean NA en red.usada ni tampoco en sexo. Para que se cumplan las dos condiciones indicamos la conjunción $y$, con el símbolo $\&$:

```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(subset(
  base.ejemplo, is.na(
    base.ejemplo$red.usada
  ) == FALSE & is.na(
    base.ejemplo$sexo
  ) == FALSE
)) +
  geom_bar(aes(red.usada, fill = sexo)) + coord_flip()
```

Aquí vemos que la preferencia por redes está bastante equilibrada entre mujeres y varones.  


El histograma tiene su propia capa, `geom_histogram`. Para el caso de la variable edad:  

```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(base.ejemplo) +
  geom_histogram(aes(edad))
```

Por defecto, se generan 30 intervalos, lo cual puede ajustarse, por ejemplo, a 15:  
```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(base.ejemplo) +
  geom_histogram(aes(edad), bins = 15)
```

Las opciones de mapeo son como con `geom_bar`:  
```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(subset(
  base.ejemplo,
  is.na(base.ejemplo$sexo) == FALSE
)) +
  geom_histogram(aes(edad, fill = sexo), bins = 15)
```

El polígono de frecuencias es una capa que se agrega al histograma:  
```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(base.ejemplo) +
  geom_histogram(aes(edad)) +
  geom_freqpoly(aes(edad))
```

Si se quiere ajustar el número de intervalos, conviene hacerlo igual en las dos capas:  
```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(base.ejemplo) +
  geom_histogram(aes(edad), bins = 15) +
  geom_freqpoly(aes(edad), bins = 15)
```

La ojiva tiene una capa llamada `stat_ecdf`, para el cálculo de la distribución de frecuencias acumuladas empíricas. Su sintaxis sigue la misma lógica: en `aes` se indica la variable que se grafica:   
```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(base.ejemplo) + stat_ecdf(aes(edad))
```


Por defecto grafica escalones, que representan los saltos de frecuencia, se puede modificar por puntos, con el argumento `geom`:

```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(base.ejemplo) + stat_ecdf(aes(edad), geom = "point")
```

O estilizando los escalones con una línea:  

```{r echo=TRUE, fig.asp = 0.7, fig.width = 3, fig.align = 'center'}
ggplot(base.ejemplo) + stat_ecdf(aes(edad), geom = "line")
```

Hay muchas opciones para mejorar la visualización de estos gráficos, que se irán presentando más adelante.

[^cuesteph]: Disponible en: https://www.indec.gob.ar/ftp/cuadros/sociedad/EPHContinua_CIndividual.pdf
[^disenoreg]: Disponible en: https://www.indec.gob.ar/ftp/cuadros/menusuperior/eph/EPH_disenoreg_09.pdf
